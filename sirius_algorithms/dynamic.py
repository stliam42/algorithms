def calc(n):
    """
    Калькулятор

    Имеется калькулятор, который выполняет три операции:
    прибавить к числу X единицу;
    умножить число X на 2;
    умножить число X на 3.
    Определите, какое наименьшее число операций необходимо для того,
    чтобы получить из числа 1 заданное число N.

    Входные данные:
    Программа получает на вход одно число, не превосходящее 106.

    Выходные данные:
    Требуется вывести одно число: наименьшее количество искомых операций.
"""
    operations = [0] * n

    for i in range(1, n):
        if (i + 1) % 6 == 0:
            operations[i] = min(operations[i//3], operations[i//2], operations[i-1]) + 1
        elif (i + 1) % 3 == 0:
            operations[i] = min(operations[i//3], operations[i-1]) + 1
        elif (i + 1) % 2 == 0:
            operations[i] = min(operations[i//2], operations[i-1]) + 1
        else:
            operations[i] = operations[i-1] + 1

    return operations


def sequences(n, k):
    """
    Без двух нулей подряд.

    Требуется посчитать количество последовательностей длины n, 
    состоящих из цифр от 0 до k−1 таких, что никакие два соседних 
    элемента последовательности не равны нулю одновременно.

    Входные данные:
    Заданы два натуральных числа N и K (2≤K≤10; 2≤N; 4≤N+K≤18).

    Выходные данные:
    Необходимо вывести целое число — ответ на задачу.
    """
    matrix = [[0 for i in range (n + 1)] for j in range(2)]
    matrix[0][1] = 1
    matrix[1][1] = k - 1

    for i in range(2, n + 1):
        matrix[0][i] = matrix[1][i-1]
        matrix[1][i] = (k - 1) * (matrix[0][i-1] + matrix[1][i-1])

    return matrix[0][-1] + matrix [1][-1]


def no_three_digits_ones(n):
    """
    Без трёх единиц.

    Определите количество последовательностей из нулей и единиц длины N 
    (длина — это общее количество нулей и единиц), 
    в которых никакие три единицы не стоят рядом.

    Входные данные:
    Дано натуральное число N, не превосходящее 40.

    Выходные данные:
    Выведите количество искомых последовательностей. 
    Гарантируется, что ответ не превосходит (2^31)−1.
    """
    matrix = [([0] * (n + 1)) for i in range(3)]
    matrix[1][1] = 1
    matrix[2][1] = 1
    
    for i in range(2, n + 1):
        matrix[0][i] = matrix[1][i-1]
        matrix[1][i] = matrix[2][i-1]
        matrix[2][i] = matrix[0][i-1] + matrix[1][i-1] + matrix[2][i-1]

    return matrix[0][-1] + matrix[1][-1] + matrix[2][-1]


def nails_range(n: int, coords: tuple) -> int:
    """
    Гвоздики.

    В дощечку в один ряд вбиты гвоздики. Любые два гвоздика можно соединить ниточкой.
    Требуется соединить некоторые пары гвоздиков ниточками так, чтобы к каждому 
    гвоздику была привязана хотя бы одна ниточка, а суммарная длина 
    всех ниточек была минимальна.

    Входные данные:
    В первой строке входных данных записано число N — количество гвоздиков (2≤N≤100).
    В следующей строке заданы N чисел — координаты всех гвоздиков 
    (неотрицательные целые числа, не превосходящие 10000, в любом порядке).

    Выходные данные:
    Выведите единственное число — минимальную суммарную длину всех ниточек.
    """
    if n == 2:
        return coords[1] - coords[0]
    dp = [0] * (n+1)
    dp[2] = coords[1] - coords[0]
    dp[3] = coords[2] - coords[0]

    for i in range(4, n+1):
        dp[i] = min(dp[i-1], dp[i-2]) + (coords[i-1] - coords[i-2])

    return dp


def ticket_queue(n: int, times: list) -> int:
    """
    Покупка билетов.

    За билетами на премьеру нового мюзикла выстроилась очередь из N человек, 
    каждый из которых хочет купить 1 билет. На всю очередь работала только одна касса,
    поэтому продажа билетов шла очень медленно, приводя «постояльцев» очереди в отчаяние. 
    Самые сообразительные быстро заметили, что, как правило, несколько билетов в одни 
    руки кассир продаёт быстрее, чем когда эти же билеты продаются по одному. 
    Поэтому они предложили нескольким подряд стоящим людям отдавать деньги 
    первому из них, чтобы он купил билеты на всех.

    Однако для борьбы со спекулянтами кассир продавала не более 3 билетов в одни руки,
    поэтому договориться таким образом между собой могли лишь 2 или 3 подряд стоящих человека.

    Известно, что на продажу i-му человеку из очереди одного билета кассир тратит Ai секунд,
    на продажу двух билетов — Bi секунд, трёх билетов — Ci секунд. Напишите программу,
    которая подсчитает минимальное время, за которое могли быть обслужены все покупатели.

    Обратите внимание, что билеты на группу объединившихся людей всегда покупает первый из них.
    Также никто в целях ускорения не покупает лишних билетов 
    (то есть билетов, которые никому не нужны).

    Входные данные:
    На вход программы поступает сначала число N — количество покупателей в очереди (1≤N≤5000).
    Далее идут N троек натуральных чисел Ai, Bi, Ci. 
    Каждое из этих чисел не превышает 3600. 
    Люди в очереди нумеруются, начиная от кассы.

    Выходные данные:
    Требуется вывести одно число — минимальное время в секундах, за которое могли быть обслужены все покупатели.
    """

    if n == 1:
        return times[0][0]
    dp = [[0] * (n + 1) for i in range(3)]
    dp[0][1] = times[0][0]
    dp[0][2] = dp[0][1] + times[1][0]

    dp[1][1] = times[0][0]
    dp[1][2] = min(dp[0][2], times[0][1])

    dp[2][1] = times[0][0]
    dp[2][2] = min(dp[0][2], times[0][1])

    for i in range(3, n + 1):
        dp[0][i] = dp[0][i-1] + times[i-1][0]
        dp[1][i] = min(dp[1][i-1] + times[i-1][0], dp[1][i-2] + times[i-2][1])
        dp[2][i] = min(dp[2][i-1] + times[i-1][0], dp[2][i-2] + times[i-2][1], dp[2][i-3] + times[i-3][2])

    return dp


def count_energy_of_jumps(n, heights: tuple) -> int:
    """
    Компьютерная игра
    Вы можете вспомнить хоть одного своего знакомого до двадцатилетнего возраста,
    который в детстве не играл в компьютерные игры? Если да, то может быть 
    вы и сами не знакомы с этим развлечением? Впрочем, трудностей при 
    решении этой задачи это создать не должно.

    Во многих старых играх с двумерной графикой можно столкнуться с 
    подобной ситуацией. Какой-нибудь герой прыгает по платформам 
    (или островкам), которые висят в воздухе. Он должен перебраться
    от одного края экрана до другого. При этом при прыжке с одной 
    платформы на соседнюю у героя уходит |y2–y1| единиц энергии,
    где y1 и y2 — высоты, на которых расположены эти платформы. 
    Кроме того, у героя есть суперприём, который позволяет перескочить
    через платформу, но на это затрачивается 3⋅|y3–y1| единиц энергии.
    Конечно же, энергию следует расходовать максимально экономно.

    Предположим, что вам известны координаты всех платформ в порядке 
    от левого края до правого. Сможете ли вы найти, какое минимальное 
    количество энергии потребуется герою, чтобы добраться с первой 
    платформы до последней?

    Входные данные:
    В первой строке записано количество платформ n (1 ≤ n ≤ 30000). 
    Вторая строка содержит n натуральных чисел, 
    не превосходящих 30000 — высоты, на которых располагаются платформы.

    Выходные данные:
    Выведите единственное число — минимальное количество энергии, 
    которую должен потратить игрок на преодоление платформ 
    (конечно же, в предположении, что cheat-коды использовать нельзя).
"""
    dp = [0] * (n)
    dp[0] = 0
    dp[1] = abs(heights[1] - heights[0])

    for i in range(2, n):
        dp[i] = min(dp[i-1] + abs(heights[i] - heights[i-1]), 
                    dp[i-2] + 3 * abs(heights[i] - heights[i-2])
                    )

    return dp[-1]


def count_ents_vocabulary(k: int, p: int) -> int:
    """
    Энты.

    Энты были созданы в Первоначальную эпоху вместе с другими обитателями 
    Средиземья. Эльфийские легенды гласят, что когда Варда зажгла звёзды 
    и пробудились эльфы, вместе с ними пробудились и энты в Великих Лесах Арды.

    Когда энты пришли в Арду, они ещё не умели говорить — этому искусству 
    их обучали эльфы, и энтам это ужасно нравилось. Им доставляло удовольствие
    изучать разные языки, даже щебетание людей.

    Эльфы выработали хорошую технику обучения энтов своему языку. Первый энт,
    которого обучили эльфы, выучил всего два слова — «tancave» (да) и «la» (нет).
    Обученный энт выбрал одного старого и одного молодого энта, не умеющих говорить,
    и обучил их всем словам, которые знал сам. Затем обучение этих двух энтов 
    продолжили сами эльфы. Каждый обучившийся у эльфов энт снова выбирал из 
    неговорящих сородичей одного старого и одного молодого, обучал их всем словам, 
    которые знал, передавал эльфам и так далее.

    Выяснилось, что более молодые энты выучивали у эльфов ещё ровно столько 
    же слов, сколько они узнали от обучавшего их энта. А вот более старые, 
    уже склонные к одеревенению энты, пополняли свой запас всего лишь одним словом. 
    После обучения у эльфов энты до конца света уже не могли выучить ни одного нового слова.

    Общее число энтов в Средиземье больше, чем вы думаете. Интересно, а сколько 
    из них знают ровно 150 квенийских слов? Похожую задачу вам предстоит решить.

    Входные данные:
    Даны натуральные числа K и P (K≤106, 1≤P≤109 ), записанные через пробел.

    Выходные данные:
    Мы понимаем, что число энтов, знающих в точности K слов, может быть 
    слишком велико, поэтому просим вывести лишь количество энтов, 
    знающих ровно K слов, по модулю P.
"""
    if k == 0 or k == 1:
        return 0
    dp = [0] * (k)
    dp[1] = 1

    for i in range(2, k):
        if (i+1) % 2 == 0:
            dp[i] = dp[i-1] + dp[i//2]
        else:
            dp[i] = dp[i-1]

    return dp

#n = int(input())
#n, p = map(int, input().split())
#list_ = [tuple(map(int, input().split())) for i in range(n)]

k, p = 0, 10
a = 36
b = -4
c = 5

print(4**(-1))

print(count_ents_vocabulary(k, p))