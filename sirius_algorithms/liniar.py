def max_fraction(n: int, a: tuple) -> tuple:
    """
    Отношение.

    Дан массив a1,a2,…an. Необходимо выбрать в нём два элемента ai и aj 
    такие, что i<j, и отношение aj/ai максимально и больше 1.

    Входные данные:
    В первой строке задано целое число 2 ≤n≤ 100 000 — количество
    элементов в массиве.
    Во второй строке заданы n целых положительных чисел 
    ai(1 ≤i≤n, 1 ≤ai≤ 5000).

    Выходные данные:
    Выведите два числа — индексы элементов i и j. Если ответов
    несколько, то выведите любой из них.
    Если ответа нет, то выведите два нуля, разделённых пробелом.
    """
    ibest = 0
    jbest = 1
    imin = 0

    for j in range(2, n):
        if a[j-1] < a[imin]:
            imin = j - 1
        if a[j] / a[imin] > a[jbest] / a[ibest]:
            ibest = imin
            jbest = j

    return (ibest+1, jbest+1) if a[jbest] / a[ibest] > 1.0 else (0, 0)


def rob_the_bank(n: int, k: int, a: tuple) -> tuple:
    """
    Клиппи и Мерлин грабят банк.

    Клиппи и Мерлин решили грабить банк, который представляет собой N 
    расположенных в ряд банковских ячеек, пронумерованных последовательно 
    числами от 1 до N.

    С помощью своего друга Ровера, который работал в банке сторожевым 
    псом, они добыли ключи от всех ячеек, а также узнали, как много 
    ценностей хранится в каждой ячейке.

    Чтобы не вызывать лишних подозрений, Клиппи и Мерлин решили ограбить
    всего две ячейки — по одной на каждого. Также, чтобы охрана банка 
    не почуяла неладного, они решили работать далеко друг от друга — 
    между ними должно быть не меньше K банковских ячеек.

    Входные данные:
    В первой строке вводятся два числа — N ( 2 ≤N≤ 105) и K (0 ≤K<N− 1) 
    соответственно. В второй строке вводятся N чисел ai(0 ≤ai≤ 109) — 
    стоимости хранимых ценностей в ячейках от 1 до N соответственно.

    Выходные данные:
    Выведите два числа в возрастающем порядке — номера ячеек, которые
    нужно ограбить, чтобы суммарно украсть как можно более дорогие ценности,
    не вызвав при этом лишних подозрений. Если вариантов несколько, выберите 
    тот, в котором меньший номер вскрываемой ячейки был бы как можно ближе 
    к единице, чтобы в экстренном случае покинуть банк как можно скорее. 
    Если и таких вариантов несколько, выберите тот, в котором и больший номер
    вскрываемой ячейки был бы как можно меньше.
"""
    ibest = 0
    jbest = k + 1
    imax = 0
    for j in range(k + 2, n):
        if a[j-(k+1)] > a[imax]:
            imax = j - (k + 1)
        if a[j] + a[imax] > a[jbest] + a[ibest]:
            ibest = imax
            jbest = j

    return (ibest, jbest)

#n = int(input())
#a = tuple(map(int, input().split()))

n = 6
a = (2,4,3,1,4,4)
k = 2

print(rob_the_bank(n, k, a))