""" 
Динамическое программирование. Задача о рюкзаке.
Метод динамического программирования состоит в разделении задачи на подзадачи.
Решение исходной задачи будет получено, как комбинация подзадач.
В случае задачи о рюкзаке, задача разбивается на подзадачи с рюкзаком меньшей вместимости
или с меньшем количеством предметов. Задача для изначального рюкзака решается как комбинация подрюкзаков.
"""

# Доступные предметы, их вес и ценность
items = {
        'water': {'weight': 3, 'cost': 12,},
        'book': {'weight': 1, 'cost': 3,},
        'food': {'weight': 2, 'cost': 9,},
        'jacket': {'weight': 2, 'cost': 5,},
        'camera': {'weight': 1, 'cost': 6,},
        'matches': {'weight': 1, 'cost': 5},
        'umbrella': {'weight': 2, 'cost': 4},
        'phone': {'weight': 1, 'cost': 8},
        'tent': {'weight': 4, 'cost': 16},
         }

# Вместимость рюкзака
capacity = 6

def best_set(items, capacity):
    """ Функция, определяющая лучший набор вещей, которые поместятся в рюкзаке"""

    # Формируем матрицы стоимостей и вещей. Матрицы бульше количества вещей и вместимости на 1.
    # Это необходимо для правильного заполнения матрицы, в процессе будет происходить обращение к
    # нулевым столбцам и строкам. Можно считать, что в рюкзак вместимость 0 влезет 0 предметов общей стоимостью 0.
    # И если в рюкзак любого размера положить 0 предметов - ох стоимость тоже будет равна нулю.

    cost_matrix = [[0 for i in range(capacity + 1)] for item in range(len(items) + 1)]
    items_matrix = [['' for i in range(capacity + 1)] for item in range(len(items) + 1)]

    # Первый цикл проходит по доступным предметам. Функция enumerate используется для того,
    # чтобы иметь возможность образаться к предметам в словаре.
    # Второй цикл проходит по подрюкзакам меньшей вместимости.
    for i, item in enumerate(items, 1):
        for j in range(1, capacity + 1):

            # Если вес текущего предмета больше, чем вместимость подрюкзака,
            # то ценность такой ячейки припавнивается текущему максимуму.
            if items[item]['weight'] > j:
                cost_matrix[i][j] = cost_matrix[i-1][j]

            # Иначе ценность ячейки будет найдена, как максимум из предыдущего максимума 
            # и ценности оставшегося пространства (которая уже найдена).
            # cell[i][j] = max(cell[i-1][j], cell[i-1][j - вес предмета].
            else:
                cost_matrix[i][j] = max(cost_matrix[i-1][j], 
                                        items[item]['cost'] + 
                                        cost_matrix[i-1][j - items[item]['weight']]
                                        )
            # Построение матрицы предметов.
            # Если стоимость текущей ячейки меньше либо равна текущему максимому,
            # то ячейка предмета так же равна предыдущему лучшему предмету. 
            # Иначе ячейка равна текущему предмету и предметам, 
            # которые поместятся в оставшемся пространстве.
            items_matrix[i][j] = (items_matrix[i-1][j] 
                                  if cost_matrix[i][j] <= cost_matrix[i-1][j] 
                                  else 
                                  item + ' - ' + items_matrix[i-1][j - items[item]['weight']])

    return cost_matrix, items_matrix

cost, items = best_set(items, capacity)

print(*cost, sep='\n')
print('')
print(*items, sep='\n')